{"name":"Vollständige Regeneration inklusive Schicksalspunkte","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/regen_all.svg","command":"let currentActor = actor;\n\nif(!currentActor) {\n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return;\n  }\n  currentActor = token.actor\n}\n\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nawait regenerate(currentActor);\n\n\n\nasync function regenerate(actor){\n  regenerateLep(currentActor);\n  regenerateAu(currentActor);\n  regenerateAsp(currentActor);\n  regenerateKap(currentActor);\n  healWounds(currentActor);\n  resetSchicksalspunkte(currentActor);\n\n  const content = `<div>${currentActor.data.name} hat vollständig regeneriert</div>`;\n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}\n\n// LeP Regeneration\nfunction regenerateLep(actor){\n  const resource = currentActor.data.data.base.resources['vitality'];\n  const newValue = regenerateResource(resource);\n  actor.update({_id: actor._id, 'data.base.resources.vitality.value': newValue});\n}\n\n// AU Regeneration\nfunction regenerateAu(actor){\n  const resource = currentActor.data.data.base.resources['endurance'];\n  const newValue = regenerateResource(resource);\n  actor.update({_id: actor._id, 'data.base.resources.endurance.value': newValue});\n}\n\n\n// AsP Regeneration\nfunction regenerateAsp(actor){\n  const resource = actor.data.data.base.resources['astralEnergy'];\n  const newValue = regenerateResource(resource);\n  actor.update({_id: actor._id, 'data.base.resources.astralEnergy.value': newValue});\n}\n\n// KaP Regeneration\nfunction regenerateKap(actor){\n  const resource = actor.data.data.base.resources['karmicEnergy'];\n  const newValue = regenerateResource(resource);\n  actor.update({_id: actor._id, 'data.base.resources.karmicEnergy.value': newValue});\n}\n\n// Wunden heilen\nfunction healWounds(actor){\n  const wounds = actor\n    .getEmbeddedCollection(\"ActiveEffect\")\n    .filter(e => e.data.label == 'Wunde');\n\n  const ids = wounds.map(w => w.data._id);\n\n  actor.deleteEmbeddedDocuments( \n    \"ActiveEffect\", \n    ids);\n}\n\n\n// Schicksalspunkte zurücksetzen\nfunction resetSchicksalspunkte(actor) {\n  try {\n    actor.data.data.base.resources['schicksalspunkte'].value;\n  } catch {\n    actor.data.data.base.resources['schicksalspunkte'] = {value: 3, min: 0, max: 3};\n    return;\n  }\n  \n  const resource = actor.data.data.base.resources['schicksalspunkte'];\n  const newValue = regenerateResource(resource);\n  actor.update({_id: actor._id, 'data.base.resources.schicksalspunkte.value': newValue});\n}\n\n\n\n// Generic Functions\nfunction regenerateResource(resource) {\n  resource.value = resource.max;\n  \n  return resource.max;\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676339682,"modifiedTime":1670676377458,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"0FcFFFCUWRMdYy0h"}
{"name":"Bruchfaktor (Primärhand)","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/broken-sword.svg","command":"let currentActor = getActor();\n\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nconst combatState = currentActor.combatState\nif(!combatState.isArmed){\n  console.log('Abort, Actor is unarmed');\n  return;\n}\n\nawait breakTest(currentActor);\n\n// Functions\nasync function breakTest(actor){\n  const name = currentActor.data.name;\n  let content = `<div style=\"font-weight: bold\">${name}</div>`\n\n  const item = combatState.primaryHand.item.data;\n  content += `<div>${item.name}</div>`;\n  const breakTestText = await checkBreak(item);\n  content += `<div style=\"margin-top: 20px; font-weight: bold\">${breakTestText}</div>`;\n\n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}\n\nasync function checkBreak(item){\n  const rollResult = await rollD6();\n  console.log(rollResult);\n  if(rollResult > item.data.breakingFactor){\n    item.data.breakingFactor += 1;\n    return `Bruchfaktor des Gegenstands ist gestiegen (${rollResult})`;\n  }\n  \n  item.data.breakingFactor = 99;\n  const brokenSuffix = ' (zerstört)';\n  if(!item.name.includes(brokenSuffix)){\n    item.name += brokenSuffix ;\n  }\n  \n  item.update({_id: item._id, name: item.name, 'data.breakingFactor': item.data.breakingFactor});\n  return `Gegenstand ist zerbrochen! (${rollResult})`;\n}\n\nasync function rollD6(){\n  const roll = await new Roll(`2d6`).evaluate();\n  let result = roll.dice[0].results[0].result;\n  result += roll.dice[0].results[1].result;\n  game.dice3d.showForRoll(roll);\n  \n  return result;\n}\n\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676609739,"modifiedTime":1670676633136,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"1hvZsXnq3zU2xYVP"}
{"name":"Schicksalspunkte Info","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/schpkt_info.svg","command":"new Dialog({\n  title: \"Schicksalspunkte Info\",\n  content:`\n<p>Anzahl der Schicksalspunkte: 2 SchiP + (1 SchiP pro 500 AP)</p>\n<table>\n<thead>\n  <tr>\n    <th>Effekt</th>\n    <th>Kosten</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>7 Lebenspunkte und eine Wunde spontan heilen</td>\n    <td>1 SchiP</td>\n  </tr>\n  <tr>\n    <td>Zufall, der das eigene Leben gerade so rettet</td>\n    <td>2 SchiP</td>\n  </tr>\n  <tr>\n    <td>Zufall, der das Leben rettet und dem Helden weiterhilft</td>\n    <td>5 Schip</td>\n  </tr>\n  <tr>\n    <td>Eine Probe wiederholen</td>\n    <td>1 SchiP</td>\n  </tr>\n  <tr>\n    <td>Eine Probe noch einmal (und noch einmal) wiederholen</td>\n    <td>2 SchiP (3 SchiP)</td>\n  </tr>\n  <tr>\n    <td>Überlebensgroßer Talentwert/Eigenschaftswert</td>\n    <td>1 SchiP pro 2 TaP/ 1 Eigenschaftspunkt</td>\n  </tr>\n  <tr>\n    <td>Geistesblitz</td>\n    <td>1 SchiP</td>\n  </tr>\n  <tr>\n    <td>Weltgestaltung / Szenenkauf</td>\n    <td>1–5 SchiP</td>\n  </tr>\n</tbody>\n</table>`,\n  buttons: {\n    roll: {\n      label: \"OK\",\n      callback: async (html) => {\n      }\n    }\n  }\n},\n{\n   width: 600\n}).render(true);","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670675830235,"modifiedTime":1670675862785,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"33UQz418DEe3imrZ"}
{"name":"Schlechte Eigenschaft","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/disadvantage_roll.svg","command":"let currentActor = getActor();\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nconst disadvantages = getDisadvantages(currentActor);\nconst disadvantagesHtml = getDisadvantagesHtml(disadvantages);\n\nnew Dialog({\n  title: \"Schlechte Eigenschaft\",\n  content:`\n    <form>\n\t    <div class=\"form-group\">\n        <label>Eigenschaft</label>\n        <select id=\"attribute\">\n          <option value=\"courage\" selected=\"selected\">MU</option>\n          <option value=\"cleverness\">KL</option>\n          <option value=\"intuition\">IN</option>\n          <option value=\"charisma\">CH</option>\n          <option value=\"dexterity\">FF</option>\n          <option value=\"agility\">GE</option>\n          <option value=\"constitution\">KO</option>\n          <option value=\"strength\">KK</option>\n        </select>\n      </div>\n\t    <div class=\"form-group\">\n        <label>Nachteil</label>\n        <select id=\"disadvantage\">\n          ${disadvantagesHtml}\n        </select>\n      </div>\n      <div class=\"form-group\">\n        <label>Modifikator</label>\n        <input type='number' id=\"modField\"></input>\n      </div>\n    </form>`,\n  buttons: {\n    roll: {\n      label: \"Roll\",\n      callback: async (html) => {\n\t\t    const attribute = html.find('[id=\"attribute\"]').val();\n        const disadvantageName = html.find('[id=\"disadvantage\"]').val();\n        \n        const modResult = html.find('[id=\"modField\"]').val();\n\t\t    let mod = 0;\n\t\t    if(modResult !== '') {\n\t\t\t    mod = Number(modResult);\n\t\t    }\n        const disadvantageValue = Number(disadvantages.find(d => d.data.name === disadvantageName).data.data.value);\n        const attributeValue = getAttributeValue(actor, attribute)\n        const check = {\n          actor: actor,\n          attribute: attribute,\n          attributeValue: attributeValue,\n          disadvantageName: disadvantageName,\n          disadvantageValue: disadvantageValue,\n          mod: mod\n        }\n        \n\t\t    const rollResult = await rollCheck(check);\n\t\t    await createChatMessage(check, rollResult);\n      }\n    }\n  }\n},\n{\n   width: 250\n}).render(true);\n\n\nasync function rollCheck(check){\n  \n  const targetValue = check.attributeValue - check.disadvantageValue + check.mod;  \n  const roll = await new Roll(`1d20`).evaluate();\n  const rollResult = roll.dice[0].results[0].result;\n  game.dice3d.showForRoll(roll);\n\n  return {\n    total: rollResult,\n    targetValue: targetValue,\n    isSuccessfull: rollResult <= targetValue,\n  }\n}\n\n\n////////////////////////////////////\n//-----------Functions------------//\n////////////////////////////////////\n//-------General Functions--------//\n////////////////////////////////////\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}\n\nfunction getDisadvantages(actor) {\n  if(!actor) {\n    return [];\n  }\n  const items = [...actor.items.values()];\n  return items.filter(i => i.data.type === 'disadvantage' && i.data.data.negativeAttribute === 1)\n}\n\nfunction getDisadvantagesHtml(disadvantages) {\n  if(!disadvantages) {\n    return '';\n  }\n  \n  let html = ''\n  for (item of disadvantages) {\n    html += `<option value=\"${item.data.name}\">${item.data.name}</option>`\n  }\n  \n  return html;\n}\n\n\nfunction getAttributeValue(actor, attributeName) {\n  return actor.data.data.base.basicAttributes[attributeName].value\n}\n\n\nasync function createChatMessage(check, roll) {\n  let content = `<div style=\"font-weight: bold\">${actor.name}</div>`;\n  content += `<div style=\"margin-top: 20px;\">${check.disadvantageName}(${check.disadvantageValue})</div>`;\n  if(roll.isSuccessfull) {\n    content += `<div style=\"font-weight: bold\">Erfolg (${roll.total})</div>`;\n  } else {\n    content += `<div style=\"font-weight: bold\">Misserfolg (${roll.total})</div>`;\n  }\n  content += `<div>${check.attributeValue - roll.total + check.mod - check.disadvantageValue}</div>`;\n \n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676700745,"modifiedTime":1670676725790,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"5R9wdz2sO1Le0Xov"}
{"name":"Fernkampfpatzer","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/criticalfail_rangedcombat.svg","command":"const table = game.tables.find(t => t.data.name === 'Fernkampfpatzer');\ntable.draw();","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676557166,"modifiedTime":1670676583884,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"5de7voVdrFyEvgWi"}
{"name":"Nahkampfpatzer","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/criticalfail_combat.svg","command":"const table = game.tables.find(t => t.data.name === 'Nahkampfpatzer');\ntable.draw();","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676517327,"modifiedTime":1670676547857,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"6igmR0B66LzTddiZ"}
{"name":"Regeneration","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"icons/svg/heal.svg","command":"let currentActor = getActor();\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nnew Dialog({\n  title: \"Regeneration\",\n  content:`\n    <form>\n      <div class=\"form-group\">\n        <label>Modifikator</label>\n        <input type='number' id=\"modField\"></input>\n      </div>\n    </form>`,\n  buttons: {\n    roll: {\n      label: \"Roll\",\n      callback: async (html) => {\n\t\tconst modResult = html.find('[id=\"modField\"]').val();\n\t\tlet mod = 0;\n\t\tif(modResult !== '') {\n\t\t\tmod = Number(modResult);\n\t\t}\n        \n\t\tconst result = await regenerate(currentActor, mod);\n\t\tawait createChatMessage(result);\n      }\n    }\n  }\n},\n{\n   width: 250\n}).render(true);\n\n\nasync function regenerate(actor, mod){\n  const lepResult = await regenerateLep(currentActor, mod);\n  const auResult = await regenerateAu(currentActor);\n  const aspResult = await regenerateAsp(currentActor, mod);\n\n  return {\n\tactor: actor,\n\tmod: mod,\n    lep: lepResult,\n    au: auResult,\n    asp: aspResult,\n  }\n}\n\n\n////////////////////////////////////\n//-----------Functions------------//\n////////////////////////////////////\n//--------LeP Regeneration--------//\n////////////////////////////////////\nasync function regenerateLep(actor, mod){\n  const resource = actor.data.data.base.resources['vitality'];\n  if(resource.value >= resource.max) {\n    return undefined;\n  }\n\n  const bonusResult = await getLepBonus(actor);\n  const regObject = {\n\tresource: resource, \n\tmod: Number(mod) + Number(bonusResult.mod),\n  };\n  const resourceResult = await regenerateResource(regObject, false); \n  const healedWounds = await tryHealWounds(actor, resourceResult.total);\n  \n  await actor.update({_id: actor._id, 'data.base.resources.vitality.value': resourceResult.newValue});\n  return {\n    bonus: bonusResult,\n\tresource: resourceResult,\n\thealedWounds: healedWounds,\n  }\n}\n\nasync function getLepBonus(actor) {\n  let mod = 0;\n  const attributeValue = getAttributeValue(actor, 'constitution')\n  const [rollResult, isSuccessfull] = await isAttributeBonusSuccessfull(attributeValue);\n  if(isSuccessfull) {\n    mod += 1;\n  }\n  \n  mod += getVitalitySpecialAbilitiesMod(actor);\n  return {\n\tmod: mod,\n    attributeValue: attributeValue,\n   \trollResult: rollResult,\n    isRollSuccessfull: isSuccessfull\n  };\n}\n\nfunction getVitalitySpecialAbilitiesMod(actor){\n  const items = [...actor.items.values()];\n  let mod = 0;\n \n  const schnelleHeilung = items.filter(i => i.data.name === 'Schnelle Heilung');\n  if(schnelleHeilung.length > 0){\n    mod += schnelleHeilung[0].data.data.value;\n  }\n \n  if(items.filter(i => i.data.name === 'Schlechte Regeneration').length > 0){\n    mod -= 1;\n  }\n\n  return mod;\n}\n\nasync function tryHealWounds(actor, healValue){\n  const healTreshold = 7;\n  if(healValue < healTreshold){\n    return 0;\n  }\n  \n  let woundHealCount = (healValue / healTreshold)|0  \n  let wounds = actor\n    .getEmbeddedCollection(\"ActiveEffect\")\n    .filter(e => e.data.label == 'Wunde');\n\n  if(!wounds || wounds.length < 1) {\n    return 0;\n  }\t\n\n  if(woundHealCount > wounds.length) {\n    woundHealCount = wounds.length;\n  }\n\n  wounds = wounds.slice(0, woundHealCount);\n  const ids = wounds.map(w => w.data._id);\n  await actor.deleteEmbeddedDocuments(\"ActiveEffect\", ids);\n  \n  return woundHealCount;\n}\n\n\n////////////////////////////////////\n//--------AU Regeneration---------//\n////////////////////////////////////\nasync function regenerateAu(actor){\n  const resource = actor.data.data.base.resources['endurance'];\n  if(resource.value >= resource.max) {\n    return undefined;\n  }\n\n  const regObject = {\n\tresource: resource, \n\tmod: 0,\n  };\n  const resourceResult = await regenerateResource(regObject, true); \n  \n  await actor.update({_id: actor._id, 'data.base.resources.endurance.value': resourceResult.newValue});\n  return {\n    bonus: undefined,\n\tresource: resourceResult,\n\thealedWounds: 0,\n  }\n}\n\n\n////////////////////////////////////\n//--------AsP Regeneration--------//\n////////////////////////////////////\nasync function regenerateAsp(actor, mod){\n  const resource = actor.data.data.base.resources['astralEnergy'];\n  if(resource.value >= resource.max) {\n    return undefined;\n  }\n\n  const bonusResult = await getAspBonus(actor);\n  const regObject = {\n\tresource: resource, \n\tmod: Number(mod) + Number(bonusResult.mod),\n  };\n  \n  let resourceResult\n  if(hasMeisterlicheRegeneration(actor)) {\n    resourceResult = await meisterlicheRegeneration(actor, regObject);\n  } else {\n    resourceResult = await regenerateResource(regObject, false); \n  }\n\n  await actor.update({_id: actor._id, 'data.base.resources.astralEnergy.value': resourceResult.newValue});\n  return {\n    bonus: bonusResult,\n\tresource: resourceResult,\n\thealedWounds: 0,\n  }\n}\n\nasync function getAspBonus(actor) {\n  let mod = 0;\n  const attributeValue = getAttributeValue(actor, 'intuition')\n  const [rollResult, isSuccessfull] = await isAttributeBonusSuccessfull(attributeValue);\n  if(isSuccessfull) {\n    mod += 1;\n  }\n  mod += getAstralSpecialAbilitiesMod(actor);\n\n  return {\n\tmod: mod,\n    attributeValue: attributeValue,\n   \trollResult: rollResult,\n    isRollSuccessfull: isSuccessfull\n  };\n}\n\nfunction getAstralSpecialAbilitiesMod(actor){\n  const items = [...actor.items.values()];\n  let mod = 0;\n \n  const astraRegeneration = items.filter(i => i.data.name === 'Astrale Regeneration');\n  if(astraRegeneration.length > 0){\n    mod += astraRegeneration[0].data.data.value;\n  }\n \n  if(items.filter(i => i.data.name === 'Regeneration I').length > 0){\n    mod += 1;\n  }\n\n  if(items.filter(i => i.data.name === 'Regeneration II').length > 0){\n    mod += 1;\n  }\n\n  if(items.filter(i => i.data.name === 'Meisterliche Regeneration').length > 0){\n    mod += 1;\n  }\n\n  if(items.filter(i => i.data.name === 'Astraler Block').length > 0){\n    mod -= 1;\n  }\n\n  return mod;\n}\n\nfunction hasMeisterlicheRegeneration(actor){\n  const items = [...actor.items.values()];\n  if(items.filter(i => i.data.name === 'Meisterliche Regeneration').length > 0){\n    return true;\n  }\n  \n  return false;\n}\n\nasync function meisterlicheRegeneration(actor, obj) {\n  const attributeValue = getAttributeValue(actor, 'intuition')\n  const total = Math.round(attributeValue / 3) + obj.mod;\n  \n  const previousValue = obj.resource.value;\n  const newValue = await getNewResourceValue(obj, total);\n\n  return {\n\ttotal: total,\n    oldValue: previousValue,\n\tnewValue: newValue,\n\tsetFull: false,\n  };\n}\n\n\n////////////////////////////////////\n//-------General Functions--------//\n////////////////////////////////////\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}\n\n\nasync function rollD6(){\n  const roll = await new Roll(`1d6`).evaluate();\n  const result = roll.dice[0].results[0].result;\n  game.dice3d.showForRoll(roll);\n  \n  return result;\n}\n\nfunction getAttributeValue(actor, attributeName) {\n  return actor.data.data.base.basicAttributes[attributeName].value\n}\n\nasync function isAttributeBonusSuccessfull(attributeValue) {\n  const roll = await new Roll(`1d20cs<=${attributeValue}`).evaluate();\n  const result = roll.dice[0].results[0].result;\n  game.dice3d.showForRoll(roll);\n  \n  return [result, roll.total];\n}\n\nasync function regenerateResource(obj, setFull) {\n  let total = 0;\n  if(setFull) {\n    total = 10000;\n  } else {\n    total = (await rollD6()) + obj.mod;\n  }\n\n  const previousValue = obj.resource.value;\n  const newValue = await getNewResourceValue(obj, total);\n\n  return {\n\ttotal: total,\n    oldValue: previousValue,\n\tnewValue: newValue,\n\tsetFull: setFull\n  };\n}\n\nasync function getNewResourceValue(obj, value) {\n  if((obj.resource.value + value) < obj.resource.max){\n    return obj.resource.value + value;\n  }\n  \n  return obj.resource.max;\n}\n\nasync function createChatMessage(result) {\n  let content = `<div style=\"font-weight: bold\">${result.actor.name}</div>`;\n  if(result.lep) {\n   const bonus = result.lep.bonus;\n   const bonusResultText = bonus.isRollSuccessfull === 1 ? '' : 'nicht';\n   content += `<div>KO-Probe war ${bonusResultText}erfolgreich (${bonus.attributeValue - bonus.rollResult})</div>`;\n  }\n  \n  if(result.asp) {\n   const bonus = result.asp.bonus;\n   const bonusResultText = bonus.isRollSuccessfull === 1 ? '' : 'nicht';\n   content += `<div>IN-Probe war ${bonusResultText} erfolgreich (${bonus.attributeValue - bonus.rollResult})</div>`;\n  }\n  \n  if(result.lep) {\n   const resource = result.lep.resource;\n   content += `<div style=\"margin-top: 20px; font-weight: bold\">LeP regeneriert: ${resource.total} (${resource.oldValue} -> ${resource.newValue})</div>`;\n  }\n  \n  if(result.au) {\n   const resource = result.au.resource;\n   content += `<div style=\"font-weight: bold\">AU regeneriert (${resource.oldValue} -> ${resource.newValue})</div>`;\n  }\n  \n  if(result.asp) {\n   const resource = result.asp.resource;\n   content += `<div style=\"font-weight: bold\">AsP regeneriert: ${resource.total} (${resource.oldValue} -> ${resource.newValue})</div>`;\n  }\n  \n  if(result.lep) {\n\tconst wounds = result.lep.healedWounds;\n    if(wounds > 0) {\n      if(wounds === 1) {\n        content += `<div style=\"font-weight: bold\">Eine Wunde wurde geschlossen</div>`;\n      } else {\n        content += `<div style=\"font-weight: bold\">${wounds} Wunden wurden geschlossen</div>`;\n      }\n    }\n  }\n  \n  if(!result.lep && !result.au && !result.asp) {\n    content += `<div style=\"margin-top: 20px; font-weight: bold\">Bereits vollständig regeneriert :)</div>`;\n  }\n  \n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676385189,"modifiedTime":1670676439123,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"7E8FUC2qc31UBQ1c"}
{"name":"LeP hinzugewinn","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/lep_add.svg","command":"let currentActor = getActor();\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nnew Dialog({\n  title: \"LeP hinzugewinn\",\n  content:`\n    <form>\n      <div class=\"form-group\">\n        <label>Anzahl oder Formel</label>\n        <input type='text' id=\"modField\"></input>\n      </div>\n    </form>`,\n  buttons: {\n    roll: {\n      label: \"OK\",\n      callback: async (html) => {\n\t\t    const modResult = html.find('[id=\"modField\"]').val();\n\t\t    let modValue = 0;\n\t\t    if(modResult !== '') {\n\t\t\t    modValue = modResult;\n\t\t    }\n        const result = await addLep(currentActor, modValue);\n        await createChatMessage(result);\n      }\n    }\n  }\n},\n{\n   width: 350\n}).render(true);\n\n////////////////////////////////////\n//-----------Functions------------//\n////////////////////////////////////\n//--------LeP Regeneration--------//\n////////////////////////////////////\nasync function addLep(actor, lepValue){\n  const resource = currentActor.data.data.base.resources['vitality'];\n  if(resource.value >= resource.max) {\n\t  return undefined;\n  }\n\n  let lepTotal = 0;\n  if(isNaN(lepValue)){\n    lepTotal = await rollDice(lepValue);\n  } else {\n    lepTotal = Number(lepValue);\n  }\n\n  const regObject = {\n\t  resource: resource, \n\t  total: lepTotal\n  };\n  \n  const resourceResult = await regenerateResource(regObject); \n  const healedWounds = await tryHealWounds(actor, lepTotal);\n  \n  await actor.update({_id: actor._id, 'data.base.resources.vitality.value': resourceResult.newValue});\n  return {\n    actor: actor,\n    total: lepTotal,\n    oldValue: resourceResult.oldValue,\n\t  newValue: resourceResult.newValue,\n\t  healedWounds: healedWounds,\n  }\n}\n\nasync function tryHealWounds(actor, healValue){\n  const healTreshold = 7;\n  if(healValue < healTreshold){\n    return 0;\n  }\n  \n  let woundHealCount = Math.floor(healValue / healTreshold);  \n  let wounds = actor\n    .getEmbeddedCollection(\"ActiveEffect\")\n    .filter(e => e.data.label == 'Wunde');\n\n  if(!wounds || wounds.length < 1) {\n    return 0;\n  }\t\n\n  if(woundHealCount > wounds.length) {\n    woundHealCount = wounds.length;\n  }\n\n  wounds = wounds.slice(0, woundHealCount);\n  const ids = wounds.map(w => w.data._id);\n  await actor.deleteEmbeddedDocuments(\"ActiveEffect\", ids);\n  \n  return woundHealCount;\n}\n\n\n\n////////////////////////////////////\n//-------General Functions--------//\n////////////////////////////////////\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}\n\n\nasync function rollDice(formula){\n  const roll = await new Roll(formula).evaluate();\n  const result = roll._total; \n  game.dice3d.showForRoll(roll);\n  \n  return result;\n}\n\n\nasync function regenerateResource(obj) {\n  const total = obj.total;\n  const previousValue = obj.resource.value;\n  const newValue = await getNewResourceValue(obj, total);\n\n  return {\n    oldValue: previousValue,\n\t  newValue: newValue\n  };\n}\n\n\nasync function getNewResourceValue(obj, value) {\n  if((obj.resource.value + value) < obj.resource.max){\n    return obj.resource.value + value;\n  }\n  \n  return obj.resource.max;\n}\n\nasync function createChatMessage(result) {\n  let content = `<div style=\"font-weight: bold\">${result.actor.name}</div>`;\n  if(!result) {\n    content += `<div style=\"margin-top: 20px; font-weight: bold\">Bereits vollständig regeneriert :)</div>`;\n  } else {\n    content += `<div style=\"margin-top: 20px; font-weight: bold\">LeP regeneriert: ${result.total} (${result.oldValue} -> ${result.newValue})</div>`;\n  \n\t  const wounds = result.healedWounds;\n    if(wounds > 0) {\n      if(wounds === 1) {\n        content += `<div style=\"font-weight: bold\">Eine Wunde wurde geschlossen</div>`;\n      } else {\n        content += `<div style=\"font-weight: bold\">${wounds} Wunden wurden geschlossen</div>`;\n      }\n    }\n  }\n  \n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670675927988,"modifiedTime":1670675959869,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"FOezyLuToN2OUSdQ"}
{"name":"Trefferpunkte erhalten","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/tp_add.svg","command":"let currentActor = getActor();\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nnew Dialog({\n  title: \"Trefferpunkte\",\n  content:`\n    <form>\n      <div class=\"form-group\">\n        <label>Anzahl oder Formel</label>\n        <input type='text' id=\"tpField\"></input>\n\t  </div>\n      <div class=\"form-group\">\n\t\t<label>Rüstung</label>\n        <input type='checkbox' id=\"armorField\" checked></input>\n      </div>\n      <div class=\"form-group\">\n        <label>Wunden</label>\n        <input type='checkbox' id=\"woundField\" checked></input>\n      </div>\n    </form>`,\n  buttons: {\n    roll: {\n      label: \"OK\",\n      callback: async (html) => {\n\t\tconst tpField = html.find('[id=\"tpField\"]').val();\n\t\tlet tpValue = 0;\n\t\tif(tpField !== '') {\n\t\t\ttpValue = tpField;\n\t\t}\n\n\t\tconst checkArmor = html.find('[id=\"armorField\"]')[0].checked;\n        const checkWounds = html.find('[id=\"woundField\"]')[0].checked;\n        const hitPointObj = {\n            actor: currentActor,\n            value: tpValue,\n            checkArmor: checkArmor,\n            checkWounds: checkWounds,\n\t\t};\n\t\t\n        const result = await dealHitPoints(hitPointObj);\n\t\tawait createChatMessage(result);\n      }\n    }\n  }\n},\n{\n   width: 350\n}).render(true);\n\n\n//////////////////////////////\n//--------Functions--------//\n/////////////////////////////\n\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}\n\nasync function dealHitPoints(hitPointObj) {\n  let armorRating = 0;\n  if(hitPointObj.checkArmor) {\n    armorRating = getActiveArmorRating(hitPointObj.actor);\n  }\n  \n  const oldLep = getCurrentLep(hitPointObj.actor);\n  const damage = await getDamage(hitPointObj.value, armorRating);\n  await dealDamage(hitPointObj.actor, damage);\n  \n  let wounds = 0;\n  if(hitPointObj.checkWounds) {\n    const woundTreshold = getWoundTreshold(hitPointObj.actor);\n    wounds = getWounds(damage, woundTreshold);\n    await addWounds(hitPointObj.actor, wounds);\n  }\n  \n  return {\n    actor: currentActor,\n    damage: damage,\n    wounds: wounds,\n\toldLep: oldLep,\n    newLep: oldLep - damage,\n  };\n}\n\nfunction getActiveArmorRating(actor) {\n  const passiveArmor = actor.data.data.base.combatAttributes.passive.physicalResistance.value;\n  const armors =  actor.items.filter(i => \n    i.data.type === 'armor' && (\n    i.data.data.equiped === true || \n    i.data.data.equipped === true));\n  \n  let activeArmor = 0;\n  for(const armor of armors) {\n    activeArmor += armor.data.data.armorClass;\n  }\n  \n  return passiveArmor + activeArmor;\n}\n\nfunction getCurrentLep(actor) {\n  return actor.data.data.base.resources['vitality'].value;\n}\n\nasync function getDamage(damageValue, armorRating) {\n  let damage = 0;\n  if(isNaN(damageValue)){\n    damage = await rollDice(damageValue);\n  } else {\n    damage = Number(damageValue);\n  }\n    \n  damage = damage - Number(armorRating);\n  if(damage < 1){\n    return 0;\n  }\n  return damage;\n}\n\nasync function rollDice(formula){\n  const roll = await new Roll(formula).evaluate();\n  let result = roll._total;\n  \n  game.dice3d.showForRoll(roll);\n  \n  return result;\n}\n\nasync function dealDamage(actor, damage) {\n  if(damage < 1){\n    return;\n  }\n  \n  const lep = getCurrentLep(actor);\n  actor.update({_id: actor._id, 'data.base.resources.vitality.value': lep - damage});\n}\n\nfunction getWoundTreshold(actor) {\n  const constitution = actor.data.data.base.basicAttributes['constitution'].value;\n  let treshold = Math.round(constitution/2);\n  \n  const eisern = [...actor.items.values()].filter(i => i.data.name === 'Eisern');\n  if(eisern.length > 0) {\n    treshold += 2;\n  }\n  \n  const glasknochen = [...actor.items.values()].filter(i => i.data.name === 'Glasknochen');\n  if(glasknochen.length > 0) {\n    treshold -= 2;\n  }\n  \n  return treshold;\n}\n\nfunction getWounds(damage, treshold) {\n  if(damage < 1){\n    return 0;\n  }\n  return Math.floor(damage / treshold);\n}\n\nasync function addWounds(actor, wounds) {\n  if(wounds < 1){\n    return;\n  }\n  \n  const woundChanges = [{\n    key: \"data.base.combatAttributes.active.baseAttack.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.combatAttributes.active.baseParry.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.combatAttributes.active.baseRangedAttack.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.combatAttributes.active.baseInitiative.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.basicAttributes.agility.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.movement.speed.value\",\n    value: -1,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  }];\n\n  let effectData = {\n    label: \"Wunde\",\n    icon: \"icons/svg/blood.svg\",\n    changes: woundChanges,\n\n    flags: {\n      core: {\n        statusId: \"wound\",\n      },\n    },\n  };\n  \n  let woundArray = [];\n  for (var i = 0; i < wounds; i++) {\n    woundArray.push(effectData);\n  }\n  \n  actor.createEmbeddedDocuments(\"ActiveEffect\", woundArray);\n  \n  return;\n}\n\nasync function createChatMessage(hitPointResult) {\n  let content = `<div>${hitPointResult.actor.name}</div>`;\n  content += `<div style=\"margin-top: 20px; font-weight: bold\">Schaden erhalten: ${hitPointResult.damage} (${hitPointResult.oldLep} -> ${hitPointResult.newLep})</div>`;\n  if(hitPointResult.wounds > 0) {\n    if(hitPointResult.wounds === 1) {\n      content += `<div style=\"font-weight: bold\">Eine Wunde wurde verursacht</div>`;\n    } else {\n      content += `<div style=\"font-weight: bold\">${woundHealCount} Wunden wurden verursacht</div>`;\n    }\n  }\n  \n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670675969969,"modifiedTime":1670675996652,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"GBUu7Lt5MjQ9oZQg"}
{"name":"Abenteuerpunkte setzen","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/xp_set.svg","command":"let currentActor = getActor();\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nnew Dialog({\n  title: \"Abenteuerpunkte setzen\",\n  content:`\n    <form>\n      <div class=\"form-group\">\n        <label>Anzahl</label>\n        <input type='text' id=\"abtPktField\"></input>\n      </div>\n    </form>`,\n  buttons: {\n    roll: {\n      label: \"OK\",\n      callback: async (html) => {\n        const abtPktField = html.find('[id=\"abtPktField\"]').val();\n        let abtPktValue = 0;\n        if(abtPktField !== '') {\n          abtPktValue = abtPktField;\n        }\n\n        if(abtPktValue < 0) {\n          return;\n        }\n        \n        const abtPktObj = {\n          actor: currentActor,\n          value: abtPktValue,\n        };\n        \n        const resultAbt = await setAbenteuerpunkte(abtPktObj);\n        const resultSch = await setSchicksalspunkte(abtPktObj);\n        \n        const result = {\n          actor: currentActor,\n          newAbtPkt: resultAbt.newAbtPkt,\n          newSchPkt: resultSch.newSchPkt,\n        };\n        \n        await createChatMessage(result);\n      }\n    }\n  }\n},\n{\n   width: 350\n}).render(true);\n\n\n/////////////////////////////\n//--------Functions--------//\n/////////////////////////////\n\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}\n\n\n\n/////////////////////////////\n//-Abenteuerpunkte  Basis-//\n/////////////////////////////\n\nasync function getAbenteuerpunkte(actor, defaultValue) {\n  try {\n    const schPkt = actor.data.data.base.resources['abenteuerpunkte'].value;\n    return schPkt;\n  } catch {\n    console.log('Creating Abenteuerpunkte attribute');\n    \n    actor.data.data.base.resources['abenteuerpunkte'] = {value: defaultValue, min: 0, max: defaultValue};\n  \n    return defaultValue;  \n  }\n}\n\nasync function setAbenteuerpunkte(abtPktObj) {\n  await getAbenteuerpunkte(abtPktObj.actor, abtPktObj.value);\n  \n  await actor.update({_id: actor._id, 'data.base.resources.abenteuerpunkte.value': abtPktObj.value});\n  await actor.update({_id: actor._id, 'data.base.resources.abenteuerpunkte.max': abtPktObj.value});\n  \n  return {\n    actor: abtPktObj.actor,\n    newAbtPkt: abtPktObj.value,\n  };\n}\n\n\n\n/////////////////////////////\n//-Schicksalspunkte  Basis-//\n/////////////////////////////\n\nasync function getSchicksalspunkte(actor, defaultValue) {\n  try {\n    const schPkt = actor.data.data.base.resources['schicksalspunkte'].value;\n    return schPkt;\n  } catch {\n    console.log('Creating Schicksalspunkte attribute');\n    \n    actor.data.data.base.resources['schicksalspunkte'] = {value: defaultValue, min: 0, max: defaultValue};\n  \n    return defaultValue;  \n  }\n}\n\nasync function setSchicksalspunkte(schPktObj) {\n  const actor = schPktObj.actor;\n  \n  const schPktValue = calculateSchicksalspunkte(schPktObj.value);\n  await getSchicksalspunkte(actor, schPktValue);\n  \n  await schPktObj.actor.update({_id: actor._id, 'data.base.resources.schicksalspunkte.value': schPktValue});\n  await schPktObj.actor.update({_id: actor._id, 'data.base.resources.schicksalspunkte.max': schPktValue});\n  \n  return {\n    actor: actor,\n    newSchPkt: schPktValue,\n  };\n}\n\nfunction calculateSchicksalspunkte(abtPktValue) {\n  const floatValue = (abtPktValue / 500) + 2;\n  return floatValue | 0;\n}\n\n\n\n/////////////////////////////\n//------Chat  Message------//\n/////////////////////////////\n\nasync function createChatMessage(abtPktResult) {\n  let content = `<div>${abtPktResult.actor.name}</div>`;\n  content += `<div style=\"margin-top: 20px; font-weight: bold\">Abenteuerpunkte gesetzt: (${abtPktResult.newAbtPkt})</div>`;\n  content += `<div style=\"margin-top: 20px; font-weight: bold\">Schicksalspunkte gesetzt: (${abtPktResult.newSchPkt})</div>`;\n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670675464936,"modifiedTime":1670675508613,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"HAr9YaIfz2crifkv"}
{"name":"Wunde heilen","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/wound_heal.svg","command":"let currentActor = getActor();\n\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nconst wounds = currentActor\n.getEmbeddedCollection(\"ActiveEffect\")\n.filter(e => e.data.label == 'Wunde');\n\nif(!wounds || wounds.length < 1) {\n  console.log('Abort, no Wounds found');\n  return;\n}\n\nconst idConvert = (v) => [].concat(v);\ncurrentActor\n.deleteEmbeddedDocuments( \n  \"ActiveEffect\", \n  idConvert(wounds[0].data._id));\n\n\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676085809,"modifiedTime":1670676151653,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"McCCfeN6W1K3RSD7"}
{"name":"Bruchfaktor (Sekundärhand)","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/broken-shield.svg","command":"let currentActor = getActor();\n\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nconst combatState = currentActor.combatState\nif(!combatState.isArmed){\n  console.log('Abort, Actor is unarmed');\n  return;\n}\n\nawait breakTest(currentActor);\n\n// Functions\nasync function breakTest(actor){\n  const name = currentActor.data.name;\n  let content = `<div style=\"font-weight: bold\">${name}</div>`\n\n  const item = combatState.secondaryHand.item.data;\n  content += `<div>${item.name}</div>`;\n  const breakTestText = await checkBreak(item);\n  content += `<div style=\"margin-top: 20px; font-weight: bold\">${breakTestText}</div>`;\n\n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}\n\nasync function checkBreak(item){\n  const rollResult = await rollD6();\n  console.log(rollResult);\n  if(rollResult > item.data.breakingFactor){\n    item.data.breakingFactor += 1;\n    return `Bruchfaktor des Gegenstands ist gestiegen (${rollResult})`;\n  }\n  \n  item.data.breakingFactor = 99;\n  const brokenSuffix = ' (zerstört)';\n  if(!item.name.includes(brokenSuffix)){\n    item.name += brokenSuffix ;\n  }\n\n  item.update({_id: item._id, name: item.name, 'data.breakingFactor': item.data.breakingFactor});\n  return `Gegenstand ist zerbrochen! (${rollResult})`;\n}\n\nasync function rollD6(){\n  const roll = await new Roll(`2d6`).evaluate();\n  let result = roll.dice[0].results[0].result;\n  result += roll.dice[0].results[1].result;\n  game.dice3d.showForRoll(roll);\n  \n  return result;\n}\n\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676634751,"modifiedTime":1670676694664,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"PD3GVWxOaAzN4NGK"}
{"name":"Schicksalspunkte nutzen","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/schpkt_sub.svg","command":"let currentActor = getActor();\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nnew Dialog({\n  title: \"Schicksalspunkte einsetzen\",\n  content:`\n    <form>\n      <div class=\"form-group\">\n        <label>Anzahl</label>\n        <input type='text' id=\"schPktField\"></input>\n      </div>\n    </form>`,\n  buttons: {\n    roll: {\n      label: \"OK\",\n      callback: async (html) => {\n        const schPktField = html.find('[id=\"schPktField\"]').val();\n        let schPktValue = 0;\n        if(schPktField !== '') {\n          schPktValue = schPktField;\n        }\n\n        if(schPktValue <= 0) {\n          return;\n        }\n        \n        const schPktObj = {\n          actor: currentActor,\n          value: schPktValue,\n        };\n        \n        const result = await subtractSchicksalspunkte(schPktObj);\n        await createChatMessage(result);\n      }\n    }\n  }\n},\n{\n   width: 350\n}).render(true);\n\n\n/////////////////////////////\n//--------Functions--------//\n/////////////////////////////\n\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}\n\n\n\n/////////////////////////////\n//-Schicksalspunkte  Basis-//\n/////////////////////////////\n\nasync function getSchicksalspunkte(actor) {\n  try {\n    const schPkt = actor.data.data.base.resources['schicksalspunkte'].value;\n    return schPkt;\n  } catch {\n    console.log('Creating Schicksalspunkte attribute');\n    \n    const defaultValue = 3;\n    actor.data.data.base.resources['schicksalspunkte'] = {value: defaultValue, min: 0, max: defaultValue};\n  \n    return defaultValue;  \n  }\n}\n\n//Nur Fluff ;)\nasync function throwChips(schPktValue){\n  const formula = `${schPktValue}d2`;\n  const roll = await new Roll(formula).evaluate();\n  \n  game.dice3d.showForRoll(roll);\n}\n\n\nasync function subtractSchicksalspunkte(schPktObj) {\n  const oldSchPkt = await getSchicksalspunkte(schPktObj.actor);\n  const newSchPkt = oldSchPkt - schPktObj.value;\n  if(newSchPkt < 0) {\n    return {\n      actor: schPktObj.actor,\n      oldSchPkt: oldSchPkt,\n      newSchPkt: newSchPkt,\n      insufficentPkt: true,\n    };\n  }\n  \n  await actor.update({_id: actor._id, 'data.base.resources.schicksalspunkte.value': newSchPkt});\n  await throwChips(schPktObj.value);\n  \n  return {\n    actor: schPktObj.actor,\n    oldSchPkt: oldSchPkt,\n    newSchPkt: newSchPkt,\n    insufficentPkt: false,\n  };\n}\n\n\n/////////////////////////////\n//------Chat  Message------//\n/////////////////////////////\n\nasync function createChatMessage(schPktResult) {\n  let content = `<div>${schPktResult.actor.name}</div>`;\n  if(!schPktResult.insufficentPkt) {\n    content += `<div style=\"margin-top: 20px; font-weight: bold\">Schicksalspunkte eingesetzt: ${schPktResult.oldSchPkt} -> ${schPktResult.newSchPkt})</div>`;\n  } else {\n    content += `<div style=\"margin-top: 20px; font-weight: bold\">Nicht genügend Schicksalspunkte (${schPktResult.oldSchPkt})</div>`;\n  }\n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670675864183,"modifiedTime":1670675897767,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"Rq3JHoit8l83PikU"}
{"name":"Unbewaffneter Nahkampfpatzer","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/criticalfail_unarmedcombat.svg","command":"const table = game.tables.find(t => t.data.name === 'Unbewaffneter Nahkampfpatzer');\ntable.draw();","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676480172,"modifiedTime":1670676515614,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"VGQMakdCG5TJVkrA"}
{"name":"Wunde hinzufügen","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/wound_add.svg","command":"const woundChanges = [\n  {\n    key: \"data.base.combatAttributes.active.baseAttack.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.combatAttributes.active.baseParry.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.combatAttributes.active.baseRangedAttack.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.combatAttributes.active.baseInitiative.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.basicAttributes.agility.value\",\n    value: -2,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n  {\n    key: \"data.base.movement.speed.value\",\n    value: -1,\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n  },\n];\n\nlet effectData = {\n  label: \"Wunde\",\n  icon: \"icons/svg/blood.svg\",\n  changes: woundChanges,\n\n  flags: {\n    core: {\n      statusId: \"wound\",\n    },\n  },\n};\n\nlet currentActor = getActor();\ncurrentActor.createEmbeddedDocuments(\n  \"ActiveEffect\", \n  [effectData]);\n\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676121111,"modifiedTime":1670676145578,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"ohFViiYXbdPm3MBD"}
{"name":"Alle Wunden heilen","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/wound_healall.svg","command":"let currentActor = getActor();\n\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nconst wounds = currentActor\n.getEmbeddedCollection(\"ActiveEffect\")\n.filter(e => e.data.label == 'Wunde');\n\nconst ids = wounds.map(w => w.data._id);\n\ncurrentActor\n.deleteEmbeddedDocuments( \n  \"ActiveEffect\", \n  ids);\n\n\n\n// Generic functions\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676038610,"modifiedTime":1670676095716,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"ptVF9rv2rjtmxldr"}
{"name":"Magieresistenzprobe","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"icons/svg/aura.svg","command":"let currentActor = actor;\n\nif(!currentActor) {\n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return;\n  }\n  currentActor = token.actor\n}\n\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nconst name = currentActor.data.name;\nconst magicResistance = currentActor.data.data.base.combatAttributes.passive.magicResistance.value;\n\nconst roll = await new Roll(`1d20cs<=${magicResistance}`).evaluate();\nconst result = roll.dice[0].results[0].result;\ngame.dice3d.showForRoll(roll); // remove this line if you dont want dice to be shown at all!\nlet content = `<div>${name}</div><div>`\ncontent += `<div>Magieresistenz (${magicResistance})</div><div>`\nif(roll.total) {\n  content += `Erfolg (${result})</div>`;\n}\nelse {\n  content += `Misserfolg (${result})</div>`;\n} \ncontent += `<div>${magicResistance-result}</div>`\nChatMessage.create({content: content});","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676729018,"modifiedTime":1670676743212,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"kt6fn2qnNkoe7DjW"}
{"name":"AsP hinzugewinn","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"modules/dsa-41-macros/icons/asp_add.svg","command":"let currentActor = getActor();\nif(!currentActor) {\n  console.log('Abort, no Actor found');\n  return;\n}\n\nnew Dialog({\n  title: \"AsP hinzugewinn\",\n  content:`\n    <form>\n      <div class=\"form-group\">\n        <label>Anzahl oder Formel</label>\n        <input type='text' id=\"modField\"></input>\n      </div>\n    </form>`,\n  buttons: {\n    roll: {\n      label: \"OK\",\n      callback: async (html) => {\n\t\t    const modResult = html.find('[id=\"modField\"]').val();\n\t\t    let modValue = 0;\n\t\t    if(modResult !== '') {\n\t\t\t    modValue = modResult;\n\t\t    }\n        const result = await addAsp(currentActor, modValue);\n        await createChatMessage(result);\n      }\n    }\n  }\n},\n{\n   width: 350\n}).render(true);\n\n////////////////////////////////////\n//-----------Functions------------//\n////////////////////////////////////\n//--------LeP Regeneration--------//\n////////////////////////////////////\nasync function addAsp(actor, aspValue){\n  const resource = currentActor.data.data.base.resources['astralEnergy'];\n  if(resource.value >= resource.max) {\n\t  return undefined;\n  }\n\n  let aspTotal = 0;\n  if(isNaN(aspValue)){\n    aspTotal = await rollDice(aspValue);\n  } else {\n    aspTotal = Number(aspValue);\n  }\n\n  const regObject = {\n\t  resource: resource, \n\t  total: aspTotal\n  };\n  \n  const resourceResult = await regenerateResource(regObject); \n  \n  await actor.update({_id: actor._id, 'data.base.resources.astralEnergy.value': resourceResult.newValue});\n  return {\n    actor: actor,\n    total: aspTotal,\n    oldValue: resourceResult.oldValue,\n\t  newValue: resourceResult.newValue,\n\t  healedWounds: healedWounds,\n  }\n}\n\n\n\n////////////////////////////////////\n//-------General Functions--------//\n////////////////////////////////////\nfunction getActor() {\n  if(actor) {\n    return actor;\n  }\n   \n  console.log('No actor found, fallback to selected token');\n  const token = canvas.tokens.controlled[0];\n\n  if(!token) {\n    console.log('Abort, no Actor found');\n    return undefined;\n  }\n  return token.actor\n}\n\n\nasync function rollDice(formula){\n  const roll = await new Roll(formula).evaluate();\n  const result = roll._total; \n  game.dice3d.showForRoll(roll);\n  \n  return result;\n}\n\n\nasync function regenerateResource(obj) {\n  const total = obj.total;\n  const previousValue = obj.resource.value;\n  const newValue = await getNewResourceValue(obj, total);\n\n  return {\n    oldValue: previousValue,\n\t  newValue: newValue\n  };\n}\n\n\nasync function getNewResourceValue(obj, value) {\n  if((obj.resource.value + value) < obj.resource.max){\n    return obj.resource.value + value;\n  }\n  \n  return obj.resource.max;\n}\n\nasync function createChatMessage(result) {\n  let content = `<div style=\"font-weight: bold\">${result.actor.name}</div>`;\n  if(!result) {\n    content += `<div style=\"margin-top: 20px; font-weight: bold\">Bereits vollständig regeneriert :)</div>`;\n  } else {\n    content += `<div style=\"margin-top: 20px; font-weight: bold\">AsP regeneriert: ${result.total} (${result.oldValue} -> ${result.newValue})</div>`;  \n  }\n  \n  ChatMessage.create({\n    user : game.user._id,\n    content: content,\n  });\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670676833228,"modifiedTime":1670677493896,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"qlBOIGlym1qi4Xts"}
{"name":"Regeneration (SesuUisu)","type":"script","scope":"global","author":"XsP72fWXQUcLRTC2","img":"icons/svg/regen.svg","command":"//Nächtliche Regeneration v0.9.4\n/**\n Makro zur Vereinfachung der nächtlichen Regeneration\n Berücksichtigt Vorteile (Schnelle Heilung, Astrale Regeneration), Nachteile (Verwöhnt, Schlechte Heilung, Astraler Block, Schlafwandler, Schlafstörung), Sonderfertigkeit (Regeneration) sowie äußere Einflusse (Schlafplatz, Wachehalten, Ruhestörung, Erkrankung) - werden automatisch ausgewählt, wenn im Token oder Actor angelegt sind.\n **/\n// Created by SesuUisu: https://github.com/SesuUisu/Foundry-DSA-Makros\n\n\nmain();\n\nasync function main() {\n\n    //Überprüfe, ob ein Token ausgewählt wurde\n    if (canvas.tokens.controlled.length === 0 || canvas.tokens.controlled.length > 1) {\n        ui.notifications.error(\"Bitte einen Token auswählen.\");\n        return;\n    }\n\n    //Charakter Werte\n    let tokenName = token.actor.name;\n\n    const lepValue = token.actor.system.base.resources.vitality.value;\n    const lepMax = token.actor.system.base.resources.vitality.max;\n    const aspValue = token.actor.system.base.resources.astralEnergy.value;\n    const aspMax = token.actor.system.base.resources.astralEnergy.max;\n    const kapValue = token.actor.system.base.resources.karmicEnergy.value;\n    const kapMax = token.actor.system.base.resources.karmicEnergy.max;\n    const aupValue = token.actor.system.base.resources.endurance.value;\n    const aupMax = token.actor.system.base.resources.endurance.max;\n\n    const constValue = token.actor.system.base.basicAttributes.constitution.value;\n    const intuValue = token.actor.system.base.basicAttributes.intuition.value;\n    const cleverValue = token.actor.system.base.basicAttributes.cleverness.value;\n\n    const showLep = lepValue < lepMax;\n    const showAsp = aspMax > 0 && aspValue < aspMax;\n    const showKap = kapMax > 0 && kapValue < kapMax;\n\n    ////Vor-/Nachtteile/SF\n    const verwohnt = token.actor.items.find(item => item.name === \"Verwöhnt\");\n    const schlafwandler = token.actor.items.find(item => item.name === \"Schlafwandler\");\n    const schlafstorung = token.actor.items.find(item => item.name === \"Schlafstörungen\");\n\n\n    //Dialog-input\n    ////general use\n    const hr = \"<hr>\";\n    const divFlexStart = \"<div style='display:flex'><span style='flex:1'>\";\n    const divFlexEnd = \"</span></div>\";\n    const divInputNumber = \"type='number' style='width:50px;float:right' value=0 />\";\n    const divInputBox = \"type='checkbox' style='width:70px;float:right' \";\n    const divInputUnchecked = \"/>\";\n    const divInputChecked = \"checked />\";\n\n\n    ////Number inputs\n    const headerDialog = \"<h2> Nächtliche Regeneration von<br><i>\" + tokenName + \"</i></h2>\";\n    let modDialog = \"\";\n    if (showLep) {\n        modDialog += divFlexStart + \"LeP-Modifikator <input id='lepFillMod'\" + divInputNumber + divFlexEnd;\n    }\n    if (showAsp) {\n        modDialog += divFlexStart + \"AsP-Modifikator <input id='aspFillMod'\" + divInputNumber + divFlexEnd;\n    }\n    if (showKap) {\n        modDialog += divFlexStart + \"KaP-Modifikator <input id='kapFillMod'\" + divInputNumber + divFlexEnd;\n    }\n    let attrModDialog = \"\";\n    if (showLep) {\n        attrModDialog += divFlexStart + \"KO-Modifikator <input id='constFillMod'\" + divInputNumber + divFlexEnd;\n    }\n    if (showAsp) {\n        attrModDialog += divFlexStart + \"IN-Modifikator <input id='intuFillMod'\" + divInputNumber + divFlexEnd;\n    }\n    ////Checkbox inputs\n    const unruheDialog = divFlexStart + \"Ruhestörung <input id='unruhe'\" + divInputBox + divInputUnchecked + divFlexEnd;\n    const wacheDialog = divFlexStart + \"Wache gehalten <input id='wache'\" + divInputBox + divInputUnchecked + divFlexEnd;\n\n    ////Dropdown inputs\n    const platzDialog = divFlexStart + `\n\t\t<form action\"#\">\n\t\t\t<label for=\"platz\">Schlafplatz</label>\n\t\t\t<select name=\"schlafplatz\" id=\"platz\" style=\"float:right\">\n\t\t\t\t<option value=\"-1\">schlechter Lagerplatz -1/-1</option>\n\t\t\t\t<option value=\"0\" selected>Schlafsaal +0/+0</option>\n\t\t\t\t<option value=\"1\">Einzelzimmer +1/+1</option>\n\t\t\t\t<option value=\"2\">Suite +2/+2</option>\n\t\t\t</select>\n\t\t</form>\n\t` + divFlexEnd;\n\n    let regenerationDialog = headerDialog + modDialog + hr + attrModDialog;\n    ////Vor-/Nachtteile/SF Input mit autofill\n    // Verwöhnt\n    const verwohntDialog = createVerwohntDialog(verwohnt);\n    regenerationDialog += verwohntDialog;\n\n    if (showLep) {\n        // Schlechte Regeneration und Schnelle Heilung\n        const heilDialog = createHeilDialog(token);\n        regenerationDialog += hr + heilDialog;\n    }\n    if (showAsp) {\n        const aspRegDialog = createAspRegDialog(token);\n        regenerationDialog += hr + aspRegDialog;\n    }\n    regenerationDialog += hr + platzDialog + unruheDialog + wacheDialog;\n    // Schlafwandler\n    if (schlafwandler) {\n        regenerationDialog += createWandelDialog(schlafwandler);\n    }\n    // Schlafstörung\n    if (schlafstorung) {\n        regenerationDialog += createInsomniaDialog(schlafstorung);\n    }\n    const krankDialog = divFlexStart + \"Erkrankt <input id='krank'\" + divInputBox + divInputUnchecked + divFlexEnd;\n    regenerationDialog += hr + krankDialog;\n    //Dialog-Fenster\n    new Dialog({\n        title: \"Nächtliche Regeneration\",\n        content: regenerationDialog,\n        buttons: {\n            close: {\n                icon: '<i class=\"fas fa-times\"></i>', label: \"Schließen\"\n            }, accept: {\n                icon: '<i class=\"fas fa-check\"></i>', label: \"Würfeln\", callback: htmlCallback\n            }\n        },\n        default: \"accept\",\n        render: () => console.log(\"Regeneration wurde geöffnet\"),\n        close: () => console.log(\"Regeneration wurde geschlossen\")\n    }).render(true);\n\n\n    function createWandelDialog(schlafwandler) {\n        let wandelCheck = divInputUnchecked;\n        let wandelOutput = \"\";\n        if (schlafwandler) {\n            let schlafRoll = new Roll('1d20').roll({async: false});\n            const rollWandelValue = schlafRoll.terms[0].results[0].result;\n            schlafRoll.toMessage({\n                flavor: \"Schlafwandler\", speaker: ChatMessage.getSpeaker({token: token.document})\n            });\n            if (rollWandelValue <= 5) {\n                wandelCheck = divInputChecked;\n                wandelOutput = \"<span style='color:#800;'> w20: \" + rollWandelValue + \"</span>\";\n                ui.notifications.warn(\"Schlafwandel wurde ausgelöst!\");\n               var table = game.tables.find(table => table.name === \"Schlafwandel\");\ntable.draw();\n            } else {\n                wandelCheck = divInputUnchecked;\n                wandelOutput = \"<span style='color:#888;'> w20: \" + rollWandelValue + \"</span>\";\n            }\n\n        }\n        return divFlexStart + \"Schlafwandeln <input id='wandel'\" + divInputBox + wandelCheck + wandelOutput + divFlexEnd;\n    }\n\n    function createInsomniaDialog(schlafstorung) {\n        let insomniaCheck = divInputUnchecked;\n        let insomniaDialogOutput = \"\";\n        if (schlafstorung) {\n            let schlafstorungRoll = new Roll('1d20').roll({async: false});\n            const rollStorungValue = schlafstorungRoll.terms[0].results[0].result;\n            const schlafstorungValue = schlafstorung.system.value;\n            schlafstorungRoll.toMessage({\n                flavor: \"Schlafstörung \" + schlafstorungValue,\n                speaker: ChatMessage.getSpeaker({token: token.document})\n            });\n            insomniaCheck = divInputUnchecked;\n            insomniaDialogOutput = \" \" + schlafstorungValue + \"<span style='color:#888;'> w20: \" + rollStorungValue + \"</span>\";\n            if (schlafstorungValue === 1) {\n                if (rollStorungValue <= 5) {\n                    insomniaCheck = divInputChecked;\n                    insomniaDialogOutput = \" \" + schlafstorungValue + \"<span style='color:#800;'> w20: \" + rollStorungValue + \"</span>\";\n                    ui.notifications.warn(\"Schlafstörung wurde ausgelöst!\");\n                }\n            } else {\n                if (rollStorungValue <= 10) {\n                    insomniaCheck = divInputChecked;\n                    insomniaDialogOutput = \" \" + schlafstorungValue + \"<span style='color:#800;'> w20: \" + rollStorungValue + \"</span>\";\n                    ui.notifications.warn(\"Schlafstörung wurde ausgelöst!\");\n                }\n            }\n\n        }\n        return divFlexStart + \"Schlafstörung <input id='insomnia'\" + divInputBox + insomniaCheck + insomniaDialogOutput + divFlexEnd;\n    }\n\n    function createVerwohntDialog(verwohnt) {\n        const verwohntValue = Number(verwohnt?.system.value || 0);\n        return divFlexStart + `\n\t\t\t\t<form action\"#\">\n\t\t\t\t\t<label for=\"tantrum\">Verwöhnt</label>\n\t\t\t\t\t<select name=\"tantrumN\" id=\"tantrum\" style=\"float:right; width: 50px;\">\n\t\t\t\t\t\t<option value=\"0\"` + (verwohntValue === 0 ? 'selected' : '') + `>0</option>\n\t\t\t\t\t\t<option value=\"1\"` + (verwohntValue === 1 ? 'selected' : '') + `>1</option>\n\t\t\t\t\t\t<option value=\"2\"` + (verwohntValue === 2 ? 'selected' : '') + `>2</option>\n\t\t\t\t\t\t<option value=\"3\"` + (verwohntValue === 3 ? 'selected' : '') + `>3</option>\n\t\t\t\t\t\t<option value=\"4\"` + (verwohntValue === 4 ? 'selected' : '') + `>4</option>\n\t\t\t\t\t\t<option value=\"5\"` + (verwohntValue === 5 ? 'selected' : '') + `>5</option>\n\t\t\t\t\t\t<option value=\"6\"` + (verwohntValue === 6 ? 'selected' : '') + `>6</option>\n\t\t\t\t\t\t<option value=\"7\"` + (verwohntValue === 7 ? 'selected' : '') + `>7</option>\n\t\t\t\t\t\t<option value=\"8\"` + (verwohntValue === 8 ? 'selected' : '') + `>8</option>\n\t\t\t\t\t\t<option value=\"9\"` + (verwohntValue === 9 ? 'selected' : '') + `>9</option>\n\t\t\t\t\t\t<option value=\"10\"` + (verwohntValue === 10 ? 'selected' : '') + `>10</option>\n\t\t\t\t\t\t<option value=\"11\"` + (verwohntValue === 11 ? 'selected' : '') + `>11</option>\n\t\t\t\t\t\t<option value=\"12\"` + (verwohntValue === 12 ? 'selected' : '') + `>12</option>\n\t\t\t\t\t</select>\n\t\t\t\t</form>\n\t\t\t` + divFlexEnd;\n    }\n\n    function createHeilDialog(token) {\n        let schnHeil = token.actor.items.find(item => item.name === \"Schnelle Heilung\");\n        let schlHeil = token.actor.items.find(item => item.name === \"Schlechte Regeneration\");\n        // Schlechte Regeneration\n        let schlHeilCheck = schlHeil ? divInputChecked : divInputUnchecked;\n        const schlHeilDialog = divFlexStart + \"Schlechte Heilung <input id='badReg'\" + divInputBox + schlHeilCheck + divFlexEnd;\n        // Schnelle Heilung\n        const schnHeilValue = Number(schnHeil?.system.value || 0);\n\n\n        const schnHeilDialog = divFlexStart + ` \n\t\t\t\t<form action\"#\">\n\t\t\t\t\t<label for=\"fastReg\">Schnelle Heilung</label>\n\t\t\t\t\t<select name=\"schnelle reg\" id=\"fastReg\" style=\"float:right; width: 50px;\">\n\t\t\t\t\t\t<option value=\"0\"` + (schnHeilValue === 0 ? \"selected\" : '') + `>0</option>\n\t\t\t\t\t\t<option value=\"1\"` + (schnHeilValue === 1 ? \"selected\" : '') + `>I</option>\n\t\t\t\t\t\t<option value=\"2\"` + (schnHeilValue === 2 ? \"selected\" : '') + `>II</option>\n\t\t\t\t\t\t<option value=\"3\"` + (schnHeilValue === 3 ? \"selected\" : '') + `>III</option>\n\t\t\t\t\t</select>\n\t\t\t\t</form>\n\t\t\t` + divFlexEnd;\n        return schlHeilDialog + schnHeilDialog;\n    }\n\n    function createAspRegDialog(token) {\n        let astraReg = token.actor.items.find(item => item.name === \"Astrale Regeneration\");\n        let astraBlock = token.actor.items.find(item => item.name === \"Astraler Block\");\n        let sfReg1 = token.actor.items.find(item => item.name === \"Regeneration I\");\n        let sfReg2 = token.actor.items.find(item => item.name === \"Regeneration II\");\n        let sfReg3 = token.actor.items.find(item => item.name === \"Meisterliche Regeneration\");\n        // Astraler Block\n        let astraBlockCheck = astraBlock ? divInputChecked : divInputUnchecked;\n        const astraBlockDialog = divFlexStart + \"Astraler Block <input id='astraBlock'\" + divInputBox + astraBlockCheck + divFlexEnd;\n\n        // Astrale Regeneration\n        let astraRegValue = astraReg?.system.value || 0;\n        let astraRegSel0 = \"\";\n        let astraRegSel1 = \"\";\n        let astraRegSel2 = \"\";\n        let astraRegSel3 = \"\";\n        switch (astraRegValue) {\n            case 0:\n                astraRegSel0 = \"selected\";\n                break;\n            case 1:\n                astraRegSel1 = \"selected\";\n                break;\n            case 2:\n                astraRegSel2 = \"selected\";\n                break;\n            case 3:\n                astraRegSel3 = \"selected\";\n                break;\n        }\n\n        let astraRegDialog = divFlexStart + ` \n\t\t\t\t<form action\"#\">\n\t\t\t\t\t<label for=\"astraReg\">Astrale Regeneration</label>\n\t\t\t\t\t<select name=\"astraRegn\" id=\"astraReg\" style=\"float:right; width: 50px;\">\n\t\t\t\t\t\t<option value=\"0\"` + astraRegSel0 + `>0</option>\n\t\t\t\t\t\t<option value=\"1\"` + astraRegSel1 + `>I</option>\n\t\t\t\t\t\t<option value=\"2\"` + astraRegSel2 + `>II</option>\n\t\t\t\t\t\t<option value=\"3\"` + astraRegSel3 + `>III</option>\n\t\t\t\t\t</select>\n\t\t\t\t</form>\n\t\t\t` + divFlexEnd;\n        // Regeneration\n        let sfRegValue = 0;\n        if (sfReg3) {\n            sfRegValue = 3;\n        } else if (sfReg2) {\n            sfRegValue = 2;\n        } else if (sfReg1) {\n            sfRegValue = 1;\n        }\n\n\n        let sfRegSel0 = \"\";\n        let sfRegSel1 = \"\";\n        let sfRegSel2 = \"\";\n        let sfRegSel3 = \"\";\n        let sfRegSel4 = \"\";\n        switch (sfRegValue) {\n            case 0:\n                sfRegSel0 = \"selected\";\n                break;\n            case 1:\n                sfRegSel1 = \"selected\";\n                break;\n            case 2:\n                sfRegSel2 = \"selected\";\n                break;\n            case 3:\n                sfRegSel3 = \"selected\";\n                break;\n        }\n\n        const sfRegDialog = divFlexStart + ` \n\t\t\t\t<form action\"#\">\n\t\t\t\t\t<label for=\"sfReg\">Regeneration (SF)</label>\n\t\t\t\t\t<select name=\"sfRegn\" id=\"sfReg\" style=\"float:right\">\n\t\t\t\t\t\t<option value=\"0\"` + sfRegSel0 + `>0</option>\n\t\t\t\t\t\t<option value=\"1\"` + sfRegSel1 + `>I</option>\n\t\t\t\t\t\t<option value=\"2\"` + sfRegSel2 + `>II</option>\n\t\t\t\t\t\t<option value=\"3\"` + sfRegSel3 + `>meisterlich (KL)</option>\n\t\t\t\t\t\t<option value=\"4\"` + sfRegSel4 + `>meisterlich (IN)</option>\n\t\t\t\t\t</select>\n\t\t\t\t</form>\n\t\t\t` + divFlexEnd;\n        return astraBlockDialog + astraRegDialog + sfRegDialog;\n    }\n\n    function createLepRegOutput(rollLepValue, rollConstValue, html, tantrumInput, placeInput, disturbedInput, wandelInput, insomniaInput, guardingInput, sickInput) {\n        let lepFInput = html.find(\"#lepFillMod\")[0]?.valueAsNumber;\n        let constFInput = html.find(\"#constFillMod\")[0]?.valueAsNumber;\n        const fastRegInput = Number(html.find(\"#fastReg\")[0]?.value || 0);\n        const badRegInput = html.find(\"#badReg\")[0]?.checked || false;\n\n        let lepFOutput;\n        if (isNaN(lepFInput) || lepFInput === \"\") {\n            lepFInput = 0;\n            lepFOutput = \"<span style='color:#800000;'>FEHLER: Manuelle LeP-Eingabe nicht übernommen.</span> <br>\";\n        } else {\n            lepFOutput = toSignedString(lepFInput) + \" LeP (manuelle Eingabe)<br>\";\n        }\n        let constFOutput;\n        if (isNaN(constFInput) || constFInput === \"\") {\n            constFInput = 0;\n            constFOutput = \"<span style='color:#800000;'>FEHLER: Manuelle KO-Eingabe nicht übernommen.</span> <br>\";\n        } else {\n            constFOutput = toSignedString(constFInput) + \" KO (manuelle Eingabe)<br>\";\n        }\n        let rollLepOutput = \"+\" + rollLepValue + \" LeP (1w6)<br>\";\n        //Schnelle Heilung\n        const lepRegMod = fastRegInput;\n        const constRegMod = -fastRegInput;\n        let lepRegModOutput = \"\";\n        let constRegModOutput = \"\";\n        switch (fastRegInput) {\n            case 1:\n                lepRegModOutput = \"+1 LeP (Schnelle Heilung I) <br>\";\n                constRegModOutput = \"-1 KO (Schnelle Heilung I) <br>\";\n                break;\n            case 2:\n                lepRegModOutput = \"+2 LeP (Schnelle Heilung II) <br>\";\n                constRegModOutput = \"-2 KO (Schnelle Heilung II) <br>\";\n                break;\n            case 3:\n                lepRegModOutput = \"+3 LeP (Schnelle Heilung III) <br>\";\n                constRegModOutput = \"-3 KO (Schnelle Heilung III) <br>\";\n                break;\n        }\n        //Schlechte Regeneration\n        let badLepRegMod = 0;\n        let constBadRegMod = 0;\n        let badLepRegModOutput = \"\";\n        let constBadRegModOutput = \"\";\n        if (badRegInput == true) {\n            badLepRegMod = -1;\n            constBadRegMod = 2;\n            badLepRegModOutput = \"-1 LeP (Schlechte Regeneration) <br>\";\n            constBadRegModOutput = \"+2 KO (Schlechte Regeneration) <br>\";\n        }\n        //Verwöhnt ff\n        let tantrumOutput = (tantrumInput > 0) ? \"+\" + tantrumInput + \" (Verwöhnt) <br>\" : \"\";\n\n        //Berechnung KO\n        const constMod = constFInput + constRegMod + constBadRegMod + tantrumInput;\n        let constModOutput = \"<i> \" + toSignedString(constMod) + \"</i>\";\n        const constTotal = rollConstValue + constMod;\n        let constBonus = 0;\n        let constBonusOutput = \"+0 LeP (KO misslungen)<br>\";\n        let constOutput;\n        if (constTotal > constValue) {\n            if (tantrumInput > 0) {\n                constBonus = -1;\n                constBonusOutput = \"-1 LeP (KO misslungen (Verwöhnt))<br>\";\n            }\n            constOutput = \"KO: <span style='color:#800000;'><b>\" + rollConstValue + constModOutput + \"</b></span> (\" + constValue + \")\";\n        } else {\n            constBonus = 1;\n            constOutput = \"KO: <span style='color:#008000;'><b>\" + rollConstValue + constModOutput + \"</b></span> (\" + constValue + \")\";\n            constBonusOutput = \"+1 LeP (KO gelungen)<br>\";\n        }\n        //Schlafstörung\n        let lepInsomnia = insomniaInput ? 1 : 0;\n        let lepInsomniaOutput = insomniaInput ? \"-1 LeP (Schlafstörung)<br>\" : \"\";\n\n        //Schlafplatz-Modifikator\n        let lepPlace = placeInput;\n        let lepPlaceOutput;\n        switch (placeInput) {\n            case -1:\n                lepPlaceOutput = \"-1 LeP (Schlechter Lagerplatz)<br>\";\n                break;\n            case 0:\n                lepPlaceOutput = \"+0 LeP (Schlafsaal)<br>\";\n                break;\n            case 1:\n                lepPlaceOutput = \"+1 LeP (Einzelzimmer)<br>\";\n                break;\n            case 2:\n                lepPlaceOutput = \"+2 LeP (Suite)<br>\";\n                break;\n        }\n        //Ruhestörung\n        let lepDisturbed = disturbedInput ? -1 : 0;\n        let lepDisturbedOutput = disturbedInput ? \"-1 LeP (Ruhestörung)<br>\" : \"\";\n\n        //Schlafwandel\n        let lepWandel = wandelInput ? -1 : 0;\n        let lepWandelOutput = wandelInput ? \"-1 LeP (Schlafwandel)<br>\" : \"\";\n\n        //Wache\n        let lepGuarding = guardingInput ? -1 : 0;\n        let lepGuardingOutput = guardingInput ? \"-1 LeP (Wache gehalten)<br>\" : \"\";\n        //Berechnung LeP\n        let lepAdd = Math.max(rollLepValue + lepFInput + constBonus + lepRegMod + badLepRegMod + lepPlace + lepDisturbed + lepGuarding + lepWandel + lepInsomnia, 0);\n\n        if (sickInput === true) {\n            lepAdd = 0;\n        }\n\n        let newLep = lepValue + lepAdd;\n        let lepUpdate = newLep;\n\n        if (newLep > lepMax) {\n            lepUpdate = lepMax;\n            lepAdd = lepMax - lepValue;\n        }\n        const lepOutput = \"LeP +<b>\" + lepAdd + \"</b>\";\n        let lepDetailOutput = rollLepOutput + lepFOutput + constBonusOutput + lepRegModOutput + badLepRegModOutput + lepPlaceOutput + lepDisturbedOutput + lepGuardingOutput + lepWandelOutput + lepInsomniaOutput;\n        if (sickInput == true) {\n            lepDetailOutput = \"Charakter ist erkrankt:<br> Keine LeP-Regeneration\";\n        }\n        const constDetailOutput = constFOutput + constRegModOutput + constBadRegModOutput + tantrumOutput;\n        return [lepUpdate, lepOutput, constOutput, lepDetailOutput, constDetailOutput];\n    }\n\n    function createAspRegOutput(rollAspValue, rollIntuValue, html, tantrumInput, placeInput, disturbedInput, wandelInput, insomniaInput, guardingInput, sickInput) {\n        let aspFInput = html.find(\"#aspFillMod\")[0]?.valueAsNumber;\n        let intuFInput = html.find(\"#intuFillMod\")[0]?.valueAsNumber;\n        const sfRegInput = Number(html.find(\"#sfReg\")[0]?.value || 0);\n        const astraRegInput = Number(html.find(\"#astraReg\")[0]?.value || 0);\n        const astraBlockInput = html.find(\"#astraBlock\")[0]?.checked || false;\n        let aspFOutput;\n\n        if (isNaN(aspFInput) || aspFInput === \"\") {\n            aspFInput = 0;\n            aspFOutput = \"<span style='color:#800000;'>FEHLER: Manuelle AsP-Eingabe nicht übernommen.</span> <br>\";\n        } else {\n            aspFOutput = toSignedString(aspFInput) + \" AsP (manuelle Eingabe)<br>\";\n        }\n        let intuFOutput;\n        if (isNaN(intuFInput) || intuFInput === \"\") {\n            intuFInput = 0;\n            intuFOutput = \"<span style='color:#800000;'>FEHLER: Manuelle IN-Eingabe nicht übernommen.</span> <br>\";\n        } else {\n            intuFOutput = toSignedString(intuFInput) + \" IN (manuelle Eingabe)<br>\";\n        }\n        //Regeneration SF\n        let sfRegAsp = sfRegInput;\n        let sfRegOutputH = \" AsP (Regeneration (SF))<br>\";\n        let rollAspOutputH = \" AsP (1w6)<br>\";\n\n        if (sfRegInput === 3) {\n            rollAspValue = Math.round(cleverValue / 3);\n            rollAspOutputH = \" AsP (KL/3)<br>\";\n        } else if (sfRegInput === 4) {\n            rollAspValue = Math.round(intuValue / 3);\n            rollAspOutputH = \" AsP (IN/3)<br>\";\n            sfRegAsp = 3;\n        }\n        const sfRegOutput = toSignedString(sfRegAsp) + sfRegOutputH;\n        const rollAspOutput = \"+\" + rollAspValue + rollAspOutputH;\n        //Astrale Regeneration\n        let aspRegMod = 0;\n        let intuRegMod = 0;\n        let aspRegModOutput = \"\";\n        let intuRegModOutput = \"\";\n        switch (astraRegInput) {\n            case 1:\n                aspRegMod = 1;\n                intuRegMod = -1;\n                aspRegModOutput = \"+1 AsP (Astrale Reg. I) <br>\";\n                intuRegModOutput = \"-1 IN (Astrale Reg. I) <br>\";\n                break;\n            case 2:\n                aspRegMod = 2;\n                intuRegMod = -2;\n                aspRegModOutput = \"+2 AsP (Astrale Reg. II) <br>\";\n                intuRegModOutput = \"-2 IN (Astrale Reg. II) <br>\";\n                break;\n            case 3:\n                aspRegMod = 3;\n                intuRegMod = -3;\n                aspRegModOutput = \"+3 AsP (Astrale Reg. III) <br>\";\n                intuRegModOutput = \"-3 IN (Astrale Reg. III) <br>\";\n                break;\n        }\n        //Astraler Block\n        let aspBlockMod = 0;\n        let intuAstraBlockMod = 0;\n        let astraBlockModOutput = \"\";\n        let intuAstraBlockModOutput = \"\";\n        if (astraBlockInput === true) {\n            aspBlockMod = -1;\n            intuAstraBlockMod = 2;\n            astraBlockModOutput = \"-1 AsP (Astraler Block) <br>\";\n            intuAstraBlockModOutput = \"+2 IN (Astraler Block) <br>\";\n        }\n\n        //Verwöhnt ff\n        const tantrumOutput = (tantrumInput > 0) ? \"+\" + tantrumInput + \" (Verwöhnt) <br>\" : \"\";\n\n        //Berechnung IN\n        let intuMod = intuFInput + intuRegMod + intuAstraBlockMod + tantrumInput;\n        const intuOutputAdd = \"<i> \" + toSignedString(intuMod) + \"</i>\";\n        const intuTotal = rollIntuValue + intuMod;\n        let intuBonus;\n        let intuBonusOutput;\n        let intuOutput;\n        if (intuTotal > intuValue) {\n            if (tantrumInput > 0) {\n                intuBonus = -1;\n                intuBonusOutput = \"-1 AsP (IN misslungen (Verwöhnt))<br>\";\n                intuOutput = \"IN: <span style='color:#888;'><b>\" + rollIntuValue + intuOutputAdd + \"</b></span> (\" + intuValue + \")\";\n            } else {\n                intuBonus = 0;\n                intuBonusOutput = \"+0 AsP (IN misslungen)<br>\";\n                intuOutput = \"IN: <span style='color:#800000;'><b>\" + rollIntuValue + intuOutputAdd + \"</b></span> (\" + intuValue + \")\";\n            }\n        } else {\n            if (sfRegInput >= 3) {\n                intuBonus = 2;\n                intuBonusOutput = \"+2 AsP (IN gelungen)<br>\";\n            } else {\n                intuBonus = 1;\n                intuBonusOutput = \"+1 AsP (IN gelungen)<br>\";\n            }\n            intuOutput = \"IN: <span style='color:#008000;'><b>\" + rollIntuValue + intuOutputAdd + \"</b></span> (\" + intuValue + \")\";\n        }\n\n        //Schlafstörung und AuP\n        const aspInsomnia = insomniaInput ? -1 : 0;\n        const aspInsomniaOutput = insomniaInput ? \"-1 AsP (Schlafstörung)<br>\" : \"\";\n\n        //Schlafplatz-Modifikator\n        let aspPlace = placeInput;\n        let aspPlaceOutput;\n        switch (placeInput) {\n            case -1:\n                aspPlaceOutput = \"-1 AsP (Schlechter Lagerplatz)<br>\";\n                break;\n            case 0:\n                aspPlaceOutput = \"+0 AsP (Schlafsaal)<br>\";\n                break;\n            case 1:\n                aspPlaceOutput = \"+1 AsP (Einzelzimmer)<br>\";\n                break;\n            case 2:\n                aspPlaceOutput = \"+2 AsP (Suite)<br>\";\n                break;\n        }\n        //Ruhestörung\n        const aspDisturbed = disturbedInput ? -1 : 0;\n        const aspDisturbedOutput = disturbedInput ? \"-1 AsP (Ruhestörung)<br>\" : \"\";\n\n        //Schlafwandel\n        const aspWandel = wandelInput ? -1 : 0;\n        const aspWandelOutput = wandelInput ? \"-1 AsP (Schlafwandel)<br>\" : \"\";\n\n        //Wache\n        const aspGuarding = guardingInput ? -1 : 0;\n        const aspGuardingOutput = guardingInput ? \"-1 AsP (Wache gehalten)<br>\" : \"\";\n\n        //Berechnung AsP\n        let aspAdd = Math.max(rollAspValue + aspFInput + intuBonus + sfRegAsp + aspRegMod + aspBlockMod + aspPlace + aspDisturbed + aspGuarding + aspWandel + aspInsomnia, 0);\n\n        if (sickInput === true && aspAdd > 1) {\n            aspAdd = 1;\n        }\n        let newAsp = aspValue + aspAdd;\n        let aspUpdate = newAsp;\n\n        if (newAsp > aspMax) {\n            aspUpdate = aspMax;\n            aspAdd = aspMax - aspValue;\n        }\n        const aspOutput = \"AsP +<b>\" + aspAdd + \"</b>\";\n        let aspDetailOutput = rollAspOutput + aspFOutput + intuBonusOutput + sfRegOutput + aspRegModOutput + astraBlockModOutput + aspPlaceOutput + aspDisturbedOutput + aspGuardingOutput + aspWandelOutput + aspInsomniaOutput;\n        const intuDetailOutput = intuFOutput + intuRegModOutput + intuAstraBlockModOutput + tantrumOutput;\n\n        if (sickInput == true) {\n            aspDetailOutput = \"Charakter ist erkrankt:<br> AsP-Regeneration auf 1 beschränkt\";\n        }\n        return [aspUpdate, aspOutput, intuOutput, aspDetailOutput, intuDetailOutput];\n    }\n\n    function createKapRegOutput(html) {\n        //Berechnung KaP\n        const kapFInput = html.find(\"#kapFillMod\")[0]?.valueAsNumber;\n        const rollKapValue = 1;\n        const rollKapOutput = \"+\" + rollKapValue + \" KaP (Basis)<br>\";\n        let kapFOutput;\n        let kapAdd = rollKapValue;\n        if (isNaN(kapFInput) || kapFInput === \"\") {\n            kapFOutput = \"<span style='color:#800000;'>FEHLER: Manuelle KaP-Eingabe nicht übernommen.</span> <br>\";\n        } else {\n            kapFOutput = toSignedString(kapFInput) + \" KaP (manuelle Eingabe)<br>\";\n            kapAdd += kapFInput;\n        }\n        if (kapAdd < 0) {\n            kapAdd = 0;\n        }\n        let newKap = kapValue + kapAdd;\n        let kapUpdate = newKap;\n        if (newKap > kapMax) {\n            kapUpdate = kapMax;\n            kapAdd = kapMax - kapValue;\n        }\n        const kapOutput = \"KaP +<b>\" + kapAdd + \"</b>\";\n        const kapDetailOutput = rollKapOutput + kapFOutput;\n        return [kapUpdate, kapOutput, kapDetailOutput];\n    }\n\n    function createAupRegOutput(insomniaInput, aupvalue) {\n        //Schlafstörung und AuP\n        let aupAdd;\n        let aupUpdate;\n        let aupDetailOutput;\n        if (insomniaInput == true) {\n            const aupHadd = Math.round(aupMax * 0.75);\n            if (aupHadd < aupvalue) {\n                aupAdd = 0;\n                aupDetailOutput = \"AuP bereits über 3/4\";\n                aupUpdate = aupvalue;\n            } else {\n                aupAdd = aupHadd - aupvalue;\n                aupDetailOutput = \"AuP über Nacht auf 3/4 regeneriert\";\n                aupUpdate = aupHadd;\n            }\n        } else {\n            aupAdd = aupMax - aupvalue;\n            aupUpdate = aupMax;\n            aupDetailOutput = \"AuP über Nacht voll regeneriert\";\n        }\n        const aupOutput = \"AuP +<b>\" + aupAdd + \"</b>\";\n        return [aupUpdate, aupOutput, aupDetailOutput];\n    }\n\n    async function htmlCallback(html) {\n        const tantrumInput = Number(html.find(\"#tantrum\")[0]?.value || 0);\n        const placeInput = Number(html.find(\"#platz\")[0].value);\n        const disturbedInput = html.find(\"#unruhe\")[0].checked;\n        const guardingInput = html.find(\"#wache\")[0].checked;\n        const wandelInput = html.find(\"#wandel\")[0]?.checked || false;\n        const insomniaInput = html.find(\"#insomnia\")[0]?.checked || false;\n        const sickInput = html.find(\"#krank\")[0].checked;\n\n        //Würfelwurf\n        let bigRoll = new Roll(buildRollExp(showLep, showAsp)).roll({async: true});\n        bigRoll.then(roll => {\n            const [rollLepValue, rollConstValue, rollAspValue, rollIntuValue] = getRollValues(roll, showLep, showAsp);\n            const [lepUpdate, lepOutput, constOutput, lepDetailOutput, constDetailOutput] = createLepRegOutput(rollLepValue, rollConstValue, html, tantrumInput, placeInput, disturbedInput, wandelInput, insomniaInput, guardingInput, sickInput);\n            const [aspUpdate, aspOutput, intuOutput, aspDetailOutput, intuDetailOutput] = createAspRegOutput(rollAspValue, rollIntuValue, html, tantrumInput, placeInput, disturbedInput, wandelInput, insomniaInput, guardingInput, sickInput);\n            const [kapUpdate, kapOutput, kapDetailOutput] = createKapRegOutput(html);\n            const [aupUpdate, aupOutput, aupDetailOutput] = createAupRegOutput(insomniaInput, aupValue);\n            //Token-Werte aktualisieren\n            token.actor.update({\n                'system.base.resources.vitality.value': lepUpdate,\n                'system.base.resources.astralEnergy.value': aspUpdate,\n                'system.base.resources.karmicEnergy.value': kapUpdate,\n                'system.base.resources.endurance.value': aupUpdate\n            });\n            //Chatausgabe\n            let message = \"<table><tr><th colspan=2>Nächtliche Regeneration</th><tr>\";\n            if (showLep) {\n                const physMessage = \"<tr><td><details><summary>\" + lepOutput + \"</summary>\" + lepDetailOutput + \"</details></td><td><details ><summary>\" + constOutput + \"</summary>\" + constDetailOutput + \"</details></td></tr>\";\n                message += physMessage;\n            }\n            if (showAsp) {\n                const astraMessage = \"<tr><td><details ><summary>\" + aspOutput + \"</summary>\" + aspDetailOutput + \"</details></td><td><details ><summary>\" + intuOutput + \"</summary>\" + intuDetailOutput + \"</details></td></tr>\";\n                message += astraMessage;\n            }\n            if (showKap) {\n                const karmicMessage = \"<tr><td><details ><summary>\" + kapOutput + \"</summary>\" + kapDetailOutput + \"</details></td><td></td></tr>\";\n                message += karmicMessage;\n            }\n            const enduMessage = \"<tr><td><details ><summary>\" + aupOutput + \"</summary>\" + aupDetailOutput + \"</details></td><td></td></tr></table>\";\n            message += enduMessage;\n\n            roll.toMessage({\n                flavor: message, speaker: ChatMessage.getSpeaker({token: token.document})\n            });\n        });\n    }\n\n    function toSignedString(n) {\n        return (n > 0 ? '+' : '') + n.toString();\n    }\n\n    function buildRollExp(showLep, showAsp) {\n        let roll = [];\n        if (showLep) {\n            roll.push('1d6');\n            roll.push('1d20');\n        }\n        if (showAsp) {\n            roll.push('1d6');\n            roll.push('1d20');\n        }\n        return '{' + roll.join(',') + '}';\n    }\n\n    function getRollValues(roll, showLep, showAsp) {\n        let rollLepValue = 0;\n        let rollConstValue = 0;\n        let rollAspValue = 0;\n        let rollIntuValue = 0;\n        if (showLep) {\n            rollLepValue = roll.dice[0].values[0];\n            rollConstValue = roll.dice[1].values[0];\n        }\n        if (showLep && showAsp) {\n            rollAspValue = roll.dice[2].values[0];\n            rollIntuValue = roll.dice[3].values[0];\n        } else if (showAsp && !showLep) {\n            rollAspValue = roll.dice[0].values[0];\n            rollIntuValue = roll.dice[1].values[0];\n        }\n        return [rollLepValue, rollConstValue, rollAspValue, rollIntuValue];\n    }\n}","folder":null,"sort":0,"ownership":{"default":0,"XsP72fWXQUcLRTC2":3},"flags":{},"_stats":{"systemId":"dsa-41","systemVersion":"0.2.7","coreVersion":"10.290","createdTime":1670677622534,"modifiedTime":1670688180912,"lastModifiedBy":"XsP72fWXQUcLRTC2"},"_id":"OhuPlNO2gvdKdqIf"}
